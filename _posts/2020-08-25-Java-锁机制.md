---
layout: post
title: Java 锁机制
categories: [java]
description: Java锁机制
keywords: java
---

# **synchronized** 

synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依 赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如 果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户 态转换到内核态，这个状态之间的转换需要相对比􏰀⻓的时间，时间成本相对􏰀高，这也是为什么早期 的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 􏰀大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优 化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销 

## 用户态和内核态

1. 内存被划分为内核态和用户态，数据在用户态和内核态之间拷贝，内核态可以访问用户态数据，反之不可以

2. 用户态无法直接访问磁盘、网卡等设备，必须通过系统提供的syscall方式调用系统函数

   ![java-内核态-用户态](/images/posts/java-内核态-用户态.png)

![sync开销](/images/posts/sync开销.png)

开销的地方

1、切换线程上下文，需要保护和恢复寄存器数据

2、切换到执行内核线程的时候，内核代码对用户不信任，需要进行额外的检查。

3、内核线程执行完返回过程有很多额外工作，比如检查是否需要调度等

4、如果被切换的线程属于不同用户程序间切换的话，那么还要更新cr3寄存器，这样会更换每个程序的虚拟内存到物理内存映射表的地址

## synchronized关键字最主要的三种使用方式 

1)修饰实例方法**:** 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁

2) 修饰静态方法**:** 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一 个实例对象，是类成员( static 表明这是该类的一个静态资源，不管new了多少个对象，只有 一份)。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用 这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 **synchronized** 方法占用的锁是当前类的锁，而访问非静态 **synchronized** 方法占用的锁是当前 实例对象锁。

3)修饰代码块**:** 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁 

## **synchronized** 关键字的底层原理

![java-sync-代码实现](/images/posts/java-sync-代码实现.png)

**synchronized** 同步语句块的实现使用的是 **monitorenter** 和 **monitorexit** 指令，其中 **monitorenter** 指令指向同步代码块的开始位置，**monitorexit** 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象 头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞 等待，直到锁被另外一个线程释放为止。 

![java-sync-代码快](/images/posts/java-sync-代码快.png)

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问 标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用 

## Sync的优化

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗 化等技术来减少锁操作的开销。 

锁主要存在四种状态，依次是:无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞
争的激烈而逐渐升级。注意锁可以升级不可降级，**无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁是单向的**,这种策略是为了提高获得锁和释放锁的效率

原文:https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/synchronized%E5%9C%A8JDK1.6%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96.md

### 偏向锁

**引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉**。

偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！（关于偏向锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。）

#### 偏向锁的加锁

当一个线程访问同步块并获取锁时, 会在锁对象的对象头和栈帧中的锁记录里存储锁偏向的线程ID, 以后该线程进入和退出同步块时不需要进行CAS操作来加锁和解锁, 只需要简单的测试一下锁对象的对象头的MarkWord里是否存储着指向当前线程的偏向锁(线程ID是当前线程), 如果测试成功, 表示线程已经获得了锁; 如果测试失败, 则需要再测试一下MarkWord中偏向锁的标识是否设置成1(表示当前是偏向锁), 如果没有设置, 则使用CAS竞争锁, 如果设置了, 则尝试使用CAS将锁对象的对象头的偏向锁指向当前线程.

#### 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制, 所以当其他线程尝试竞争偏向锁时, 持有偏向锁的线程才会释放锁. 偏向锁的撤销需要等到全局安全点(在这个时间点上没有正在执行的字节码). 首先会暂停持有偏向锁的线程, 然后检查持有偏向锁的线程是否存活, 如果线程不处于活动状态, 则将锁对象的对象头设置为无锁状态; 如果线程仍然活着, 则锁对象的对象头中的MarkWord和栈中的锁记录要么重新偏向于其它线程要么恢复到无锁状态, 最后唤醒暂停的线程(释放偏向锁的线程).

但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。

### 轻量级锁

倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。**轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。** 关于轻量级锁的加锁和解锁的原理可以查看《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版的13章第三节锁优化。

**轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！**

### 自旋锁和自适应自旋

轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。

互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。

**一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。** 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。**为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋**。

百度百科对自旋锁的解释：

> 何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。

自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过`--XX:+UseSpinning`参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。**自旋次数的默认值是10次，用户可以修改`--XX:PreBlockSpin`来更改**。

另外,**在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了**。

### 锁消除

锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。

### 锁粗化

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。

大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。



### 重量级锁

也称为阻塞同步、悲观锁

重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也称为互斥锁

为什么重量级线程开销很大的？

当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。



# **synchronized**和**ReentrantLock** 的区别

 

* ## 两者都是可重入锁 

两者都是可重入锁。“可重入锁”概念是:自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当这个线程再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。因为同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器 下降为0时才能释放锁。 

- ## synchronized依赖于 **JVM** 而 **ReentrantLock** 依赖于 **API** 

synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关 键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。 ReentrantLock 是 JDK 层面实现的(也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成)，所以我们可以通过查看它的源代码，来看它是如何实现的。 

- ## ** ReentrantLock** 比 **synchronized** 增加了一些高级功能 

相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点:

### **1**.等待可中断;

**ReentrantLock**提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实 

现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。

### **2**.可实现公平锁;

**ReentrantLock**可以指定是公平锁还是非公平锁。而**synchronized**只能是非公平锁。所谓的公平 锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock 类的 ReentrantLock(boolean fair) 构造方法来制定是否是公平的。

### **3**.可实现选择性通知(锁可以绑定多个条件) 

 synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制， ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。 Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一 个Lock对象中可以创建多个Condition实例(即对象监视器)，线程对象可以注册在指定的 **Condition**中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 **notify()/notifyAll()**方法进行通知时，被通知的线程是由 **JVM** 选择的，

用**ReentrantLock**类结 合**Condition**实例可以实现**“**选择性通知**”** ，这个功能非常重要，而且是Condition接口默认提供 的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注 册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成 很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所 有等待线程。 

# ReentrantLock的具体实现

CAS+AQS队列

原文:https://blog.csdn.net/fuyuwei2015/article/details/83719444

## AbstractQueuedSynchronizer 

AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如 我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue， FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求 的同步器。 

**AQS**核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且 将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒 时锁分配的机制，这个机制**AQS**是用**CLH**队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 

CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实 例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个 结点(Node)来实现锁的分配 



### AQS(AbstractQueuedSynchronizer)原理图 ：

![clh队列](/images/posts/clh队列.png)

AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS 使用CAS对该同步状态进行原子操作实现对其值的修改。 

```java
private volatile int state;//共享变量，使用volatile修饰保证线程可⻅性
```

状态信息通过protected类型的getState，setState，compareAndSetState进行操作 

```java
//返回同步状态的当前值
protected final int getState() {
         return state;
 }
// 设置同步状态的值
protected final void setState(int newState) {
         state = newState;
}
//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值) protected final boolean compareAndSetState(int expect, int update) {
         return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

### **AQS** 对资源的共享方式 

**AQS**定义两种资源共享方式 

**Exclusive**(独占):只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁: 公平锁:按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁:当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 

**Share**(共享):多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、 CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。

ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线 程同时对某一资源进行读。 

不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经 在顶层实现好了。 



### **AQS**底层使用了模板方法模式 

同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样(模板方法模式很经典 

的一个应用): 

1. 使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对 于共享资源state的获取和释放) 

2. 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写 的方法。 

```
这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。
```

**AQS**使用了模板方法模式，自定义同步器时需要重写下面几个**AQS**提供的模板方法: 

isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败;0表示成功，但没有剩余可用资源;正 数表示成功，且有剩余资源。 tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。 

默认情况下，每个方法都抛出 UnsupportedOperationException 。 这些方法的实现必须是内部线程安全 的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这 几个方法可以被其他类使用。 

以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占 该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0(即释 放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的 (state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state 是能回到零态的。 

再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N(注意N要与线程个数一 致)。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。 

一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-
 tryRelease 、 tryAcquireShared-tryReleaseShared 中的一种即可。但AQS也支持自定义同步器同时实现 独占和共享两种方式，如 ReentrantReadWriteLock 。 

推荐两篇 AQS 原理和相关源码分析的文章:

 http://www.cnblogs.com/waterystone/p/4920797.html 

 https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html

###  AQS 组件总结 

**Semaphore(**信号量**)-**允许多个线程同时访问: synchronized 和 ReentrantLock 都是一次只允 许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 **CountDownLatch** (倒计时器): CountDownLatch是一个同步工具类，用来协调多个线程之间的 同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执 行。 

**CyclicBarrier(**循环栅栏**)**: CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程 间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用(Cyclic)的屏障 

(Barrier)。它要做的事情是，让一组线程到达一个屏障(也可以叫同步点)时被阻塞，直到 最后一个线程到达屏障时，屏障才会开⻔，所有被屏障拦截的线程才会继续干活。 CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数 量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。 



# Atomic

AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作， 

从而避免 synchronized 的高开销，执行效率大为提升。 

CAS的原理是拿期望的值和原本的一个值作比􏰀，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可⻅，因此 JVM 可以保证任何时刻任何线 程总能拿到该变量的最新值。 

```java
// setup to use Unsafe.compareAndSwapInt for updates(更新操作时提供“比􏰀并替换”的作用) private static private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;
static { try {
             valueOffset = unsafe.objectFieldOffset
                 (AtomicInteger.class.getDeclaredField("value"));
         } catch (Exception ex) { throw new Error(ex); }
     }
private volatile int value;
```



