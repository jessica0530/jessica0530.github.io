---
layout: post
title: Java垃圾回收
categories: [java]
description: Java垃圾回收
keywords: java
---

# 垃圾回收算法

## 标记**-**清除算法

算法分为“标记”和“清除”阶段:首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的 对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个 明显的问题:

1. 效率问题
2. 空间问题(标记清除后会产生大量不连续的碎片) 

![java-标记-清除](/images/posts/java-标记-清除.png)

## 复制算法 

为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一 块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。 这样就使每次的内存回收都是对内存区间的一半进行回收 

![java-标记复制](/images/posts/java-标记复制.png)



## 标记**-**整理算法 

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接 

对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

![java-标记整理](/images/posts/java-标记整理.png)

## 分代收集算法 

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不 同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适 的垃圾收集算法。 

比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制 成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分 配担保，所以我们必须选择**“**标记**-**清除**”**或**“**标记**-**整理**”**算法进行垃圾收集 



# 常⻅的垃圾回收器 

## **Serial**收集器 

Serial(串行)收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是 一个单线程收集器了。它的 **“**单线程**”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收 集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程( **"Stop The World"** )，直到它收集结束 。

新生代采用复制算法，老年代采用标记**-**整理算法 。

它简单而高效(与其他收集器的单线 程相比)。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。**Serial收集 器对于运行在Client模式下的虚拟机来说是个不错的选择**。 

## **ParNew**收集器 

**ParNew**收集器其实就是**Serial**收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制 

参数、收集算法、回收策略等等)和**Serial**收集器完全一样。 

新生代采用复制算法，老年代采用标记**-**整理算法 

它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真 正意义上的并发收集器，后面会介绍到)配合工作。 

并行和并发概念补充: 

并行(**Parallel**) :指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 

并发(**Concurrent**):指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执 行)，用户程序在继续运行，而垃圾收集器运行在另一个CPU上。 



## **CMS**收集器

 **CMS**(**Concurrent Mark Sweep**)收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合 

在注重用户体验的应用上使用。

**CMS**(**Concurrent Mark Sweep**)收集器是**HotSpot**虚拟机第一款真正意义上的并发收集器，它第一次实 现了让垃圾收集线程与用户线程(基本上)同时工作。 

从名字中的**Mark Sweep**这两个词可以看出，CMS收集器是一种 **“**标记**-**清除**”**算法实现的，它的运作过程 相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤: 

1.初始标记: 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ;
2.并发标记: 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 

3.重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变 动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍⻓，远远比 并发标记阶段时间短 

4.并发清除: 开启用户线程，同时GC线程开始对为标记的区域做清扫 

![java-cms](/images/posts/java-cms.png)

主要优点:并发收集、低停顿。但是它有下面三个 明显的缺点: 对**CPU**资源敏感;
 无法处理浮动垃圾; 它使用的回收算法**-“**标记**-**清除**”**算法会导致收集结束时会有大量空间碎片产生 

## **G1**收集器

**G1 (Garbage-First)**是一款面向服务器的垃圾收集器**,**主要针对配备多核处理器及大容量内存的机器**.** 

以极高概率满足**GC**停顿时间要求的同时**,**还具备高吞吐量性能特征**.** 

被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点: 

1.并行与并发:G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU(CPU或者CPU核心)来缩 短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍 然可以通过并发的方式让java程序继续执行。 

2.分代收集:虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概 念。

3.空间整合:与CMS的“标记--清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器;从局部上来看是基于“复制”算法实现的。 

4.可预测的停顿:这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点， 但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个⻓度为M 毫秒的时间片段内。 



G1收集器的运作大致分为以下几个步骤: 

```
1.初始标记
2.并发标记
3.最终标记
4.筛选回收
```

G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果.

G1**收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的**Region(**这 也就是它的名字**Garbage-First**的由来**)**。这种使用Region划分内存空间以及有优先级的区域回收方式， 保证了GF收集器在有限时间内可以尽可能高的收集效率(把内存化整为零) 



## Shenandoah

那Shenandoah相比起G1又有什么改进呢？虽然Shenandoah也是使用基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region……但在管理堆内存方面，它与G1至少有三个明显的不同之处，最重要的当然是支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发，这点作为Shenandoah最核心的功能稍后笔者会着重讲解

其次，Shenandoah（目前）是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在，没有实现分代，并不是说分代对Shenandoah没有价值，这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上。最后，Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题

Shenandoah是第一款使用到读屏障的收集器，它的开发者也意识到数量庞大的读屏障带来的性能开销会是Shenandoah被诟病的关键点之一[插图]，所以计划在JDK 13中将Shenandoah的内存屏障模型改进为基于引用访问屏障（Load ReferenceBarrier）[插图]的实现，所谓“引用访问屏障”是指内存屏障只拦截对象中数据类型为引用类型的读写操作，而不去管原生数据类型等其他非引用字段的读写，这能够省去大量对原生类型、对象比较、对象加锁等场景中设置内存屏障所带来的消耗


## ZGC收集器

ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下[插图]，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟

ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器

ZGC的Region可以具有如图3-19所示的大、中、小三类容量：·小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。·中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。·大型Region（Large Region）：容量不固定，可以动态变化



# 收集器的权衡

衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency）

应用程序的主要关注点是什么？如果是数据分析、科学计算类的任务，目标是能尽快算出结果，那吞吐量就是主要关注点；如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的

那就根据内存规模衡量一下，对于大概4GB到6GB以下的堆内存，CMS一般能处理得比较好，而对于更大的堆内存，可重点考察一下G1



