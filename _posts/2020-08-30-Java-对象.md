---
layout: post
title: Java 对象
categories: [java]
description: Java 对象
keywords: java
---



# Java对象创建![java-对象创建过程](/images/posts/java-对象创建过程.png)

1.类加载检查: 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到 这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那 必须先执行相应的类加载过程。 

**2**.分配内存: 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类 加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分 配方式有 **“**指针碰撞**”** 和 **“**空闲列表**”** 两种，选择那种分配方式由 **Java** 堆是否规整决定，而**Java堆是 否规整又由所采用的垃圾收集器是否带有压缩整理功能决定** 

## 内存分配的两种方式

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"(也称作"标记-压缩")，值得注意的是，复制算法内存也是规整的 

![Java-内存分配](/images/posts/Java-内存分配.png)

**3**.初始化零值: 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象 头)，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这 些字段的数据类型所对应的零值。 

**4**.设置对象头: 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实 例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对 象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**5**.执行 **init** 方法: 在上面工作都完成之后，从虚拟机的视⻆来看，一个新的对象已经产生了，但从 Java 程序的视⻆来看，对象创建才刚开始， <init> 方法还没有执行，所有的字段都还为零。所以一 般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一 个真正可用的对象才算完全产生出来  



# 对象的访问定位 

建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**1**.使用句柄和**2**.直接指针两种:

1.句柄: 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

![java句柄](/images/posts/java句柄.png)



2.直接指针: 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型 数据的相关信息，而reference 中存储的直接就是对象的地址 

![java-直接指针](/images/posts/java-直接指针.png)

这两种对象访问方式各有优势。使用句柄来访问的最大好处是 **reference** 中存储的是稳定的句柄地 址，在对象被移动时只会改变句柄中的实例数据指针，而 **reference** 本身不需要修改。使用直接指针 访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

## 判断对象是否存活

### 引用计数法 

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1;当引用失效，计数器就减1;任 何时候计数器为0的对象就是不可能再被使用的。 

### 可达性分析算法 

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索， 节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的 

![java-可达性分析](/images/posts/java-可达性分析.png)

## 强引用**,**软引用**,**弱引用**,**虚引用 





 