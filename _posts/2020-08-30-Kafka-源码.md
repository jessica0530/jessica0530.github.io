---
layout: post
title: Kafka Producer和Consumer
categories: [kafka]
description: Kafka源码
keywords: kafka
---

支持高并发,高可用,高性能的分布式消息系统

# Producer生产数据的流程

![kafka-producer-arch](/images/posts/kafka-producer-arch.png)

![kafka-producer流程](/images/posts/kafka-producer流程.jpg)

Kafka -> ProducerInterceptors(拦截器)->Serializer->Partitioner(分区器)

RecordAccumulator （Dqueue[RecordBatch]）



Sender线程  去  RecordAccumulator去读取数据,封装多个ClientRequest发送给NetWorkClient,Sender线程 接收到请求 再回调 Producer 的 Callback

NetWorkClient (多个ClientRequest)   接到请求返回给 Sender线程

Selector (KafkaChannel)  发送给 Kafka集群 执行网络请求,返回响应



Sender(NetworkClient(Selector))



Acks：0: producer 发送数据到 broker后,就完了,没有返回值

​           1: producer发送数据到broker后,数据成功写入 leader partition 以后返回响应

​          -1: producer 发送数据到 broker后,数据写入到leader partition里面,并且数据同步到所有的follower partition

Sender发送消息的过程

## KSelector

# ![Kselector](/images/posts/Kselector.png)

# Broker端

## broker如何接收数据(高并发)



## 数据写入(leader partition)

ISR 集合表示 目前可用且消息量与Leader相差不多的副本集合

## 副本的数据同步(HW,LEO)

HighWatermark 由Leader副本管理的,当ISR集合中全部的Followe副本都拉取HW指定消息进行同步后,Leader副本会递增HW的值



LEO (Log End Offset) 是所有副本都有个 offset的记录,表示追加到 当前副本的最后一个消息的offset

如果 所有副本都完成了对 某个offset 的消息同步,Leader副本会递增其 HW

![kafka-hw-leo](/images/posts/kafka-hw-leo.png)

![kafka-高水位](/images/posts/kafka-高水位.png)

![kafka-leader-follower](/images/posts/kafka-leader-follower.png)

同步复制的缺点要求所有能工作的Followe副本都赋值完,故障的followe会 拖慢系统性能

异步复制的,如果leader收到消息就认为成功,如果保存消息量远远落后于Leader,Leader一旦宕机,就会出现消息丢失

Kafka权衡了 这两种策略,引入ISR集合,如果Follower延迟高就被踢出ISR,Leader宕机的话,Follower也能保存HW之前的信息

## 

## kafka的集群管理(controller-> zookeeper)



# Consumer消费数据





# 限速的实现和PageCache



producer生产消息时，会使用pwrite()系统调用【对应到Java NIO中是FileChannel.write() API】按偏移量写入数据，并且都会先写入page cache里。consumer消费消息时，会使用sendfile()系统调用【对应FileChannel.transferTo() API】，零拷贝地将数据从page cache传输到broker的Socket buffer，再通过网络传输。



![kafka-pagecache](/images/posts/kafka-pagecache.png)



# 内存管理机制

BufferPool.allocate负责从缓冲池中申请ByteBuffer，当缓冲区中 内存不足就会阻塞调用线程



Deallocate 负责释放线程







