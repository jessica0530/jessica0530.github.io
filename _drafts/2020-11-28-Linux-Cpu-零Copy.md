---
layout: post
title: Linux 零Copy
categories: [linux]
description: Linux 零Copy
keywords: linux
---

https://www.cnblogs.com/rickiyang/p/13265043.html

# Linux 文件系统简介

## 系统调用

处理器设有两种模式：**用户模式** 与 **内核模式**

当我们处在用户态但是却不得不调用内核态下一些操作的时候这时候可以利用Linux提供的一些转换接口唤起操作，而连接用户模式和内核模式的接口称之为 **系统调用**。

应用程序代码运行在用户模式下，当应用程序需要实现内核模式下的指令时，先向操作系统发送调用请求。操作系统收到请求后，执行系统调用接口，使处理器进入内核模式。当处理器处理完系统调用操作后，操作系统会让处理器返回用户模式，继续执行用户代码。

进程的虚拟地址空间可分为两部分，**内核空间** 和 **用户空间**。内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于**虚拟空间中，都是对物理地址的映射**。

## 虚拟文件系统

一个操作系统可以支持多种底层不同的文件系统(比如 NTFS, FAT, ext3, ext4)，为了给内核和用户进程提供统一的文件系统视图，Linux 在用户进程和底层文件系统之间加入了一个抽象层，即虚拟文件系统( Virtual File System, VFS )，进程所有的文件操作都通过 VFS，由 VFS 来适配各种底层不同的文件系统，完成实际的文件操作。

通俗的说，VFS 就是定义了一个通用文件系统的接口层和适配层，一方面为用户进程提供了一组统一的访问文件，目录和其他对象的统一方法，另一方面又要和不同的底层文件系统进行适配。

![虚拟文件系统](/Users/jessica/ideaproject-github/jessica0530.github.io/images/posts/虚拟文件系统.jpg)



1. 超级块(super_block)，用于保存一个文件系统的所有元数据，相当于这个文件系统的信息库，为其他的模块提供信息。因此一个超级块可代表一个文件系统。文件系统的任意元数据修改都要修改超级块。超级块对象是常驻内存并被缓存的。
2. 目录项模块，管理路径的目录项。比如一个路径 `/usr/local/hello.txt`，那么目录项有 usr, local, hello.txt。目录项的块，存储的是这个目录下的所有的文件的 `inode` 号 和 文件名 等信息。其内部是树形结构，操作系统检索一个文件，都是从根目录开始，按层次解析路径中的所有目录，直到定位到文件。
3. inode 模块，管理一个具体的文件，是文件的唯一标识，一个文件对应一个 inode。通过 inode 可以方便的找到文件在磁盘扇区的位置。同时 inode 模块可链接到 address_space 模块，方便查找自身文件数据是否已经缓存。
4. 打开文件列表模块，包含所有内核已经打开的文件。已经打开的文件对象由 open 系统调用在内核中创建，也叫**文件句柄**。打开文件列表模块中包含一个列表，每个列表表项是一个结构体 struct file，结构体中的信息用来表示打开的一个文件的各种状态参数。
5. file_operations 模块。这个模块中维护一个数据结构，是一系列函数指针的集合，其中包含所有可以使用的系统调用函数，例如 open、read、write、mmap 等。每个打开文件(打开文件列表模块的一个表项)都可以连接到 file_operations 模块，从而对任何已打开的文件，通过系统调用函数，实现各种操作。
6. address_space 模块，它表示一个文件在页缓存中已经缓存了的物理页。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么 address_space 可以说关联了内存系统和文件系统。我们会在后面继续讨论

## I/O 缓冲区

### **概念**

如高速缓存(cache)产生的原理类似，在 I/O 过程中，读取磁盘的速度相对内存读取速度要慢的多。因此为了能够加快处理数据的速度，需要将读取过的数据缓存在内存里。而这些缓存在内存里的数据就是高速缓冲区(buffer cache)，下面简称为 **buffer**。

具体来说，buffer 是一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。一方面，通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。另一方面，可以保护硬盘或减少网络传输的次数。

### **Buffer 和 Cache**

buffer 和 cache 是两个不同的概念：

cache 是高速缓存，用于 CPU 和内存之间的缓冲；

buffer是 I/O 缓存，用于内存和硬盘的缓冲。

简单的说，cache 是加速 **读**，而 buffer 是缓冲 **写**，前者解决读的问题，保存从磁盘上读出的数据，后者是解决写的问题，保存即将要写入到磁盘上的数据。



Page Cache 页缓存是面向文件，面向内存的。通俗来说，它位于内存和文件之间缓冲区，文件 I/O 操作实际上只和 page cache 交互，不直接和内存交互。page cache 可以用在所有以文件为单元的场景下，比如网络文件系统等等。page cache 通过一系列的数据结构，比如 inode, address_space, struct page，实现将一个文件映射到页的级别：

1. struct page 结构标志一个物理内存页，通过 `page + offset` 就可以将此页帧定位到一个文件中的具体位置。同时 `struct page` 还有以下重要参数：
   1. 标志位 flags 来记录该页是否是脏页，是否正在被写回等等；
   2. mapping 指向了地址空间 address_space，表示这个页是一个页缓存中的页，和一个文件的地址空间对应；
   3. index 记录这个页在文件中的页偏移量；
2. 文件系统的 inode 实际维护了这个文件所有的( block )的块号，通过对文件偏移量 offset 取模可以很快定位到这个偏移量所在的文件系统的块号，磁盘的扇区号。同样，通过对文件偏移量 offset 进行取模可以计算出偏移量所在的页的偏移量。
3. page cache 缓存组件抽象了地址空间 address_space 这个概念来作为文件系统和页缓存的中间桥梁。地址空间 address_space 通过指针可以方便的获取文件 inode 和 struct page 的信息，所以可以很方便地定位到一个文件的 offset 在各个组件中的位置，即通过：**文件字节偏移量 --> 页偏移量 --> 文件系统块号 block --> 磁盘扇区号**。
4. 页缓存实际上就是采用了一个基数树结构将一个文件的内容组织起来存放在物理内存 struct page 中。一个文件 inode 对应一个地址空间 address_space。而一个 address_space 对应一个页缓存基数树，它们之间的关系如下：

## 传统 I/O 存在哪些问题

在 Linux 系统中，传统的访问方式是通过 `write()` 和 `read()` 两个系统调用实现的，通过 `read()` 函数读取文件到到缓存区中，然后通过 `write()`方法把缓存中的数据输出到网络端口，伪代码如下：

图分别对应传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷贝、2 次 DMA 拷贝总共 4 次拷贝，以及 4 次上下文切换，下面简单地阐述一下相关的概念。

![I:O读取流程](/Users/jessica/ideaproject-github/jessica0530.github.io/images/posts/I:O读取流程.jpg)

关键名词解释：

**上下文切换**：当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。

**CPU 拷贝**：由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。

**DMA 拷贝**：由 CPU 向 DMA 磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。

当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据；如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存(read buffer)中，再从读缓存拷贝到用户进程的页内存中。

```java
read(file_fd, tmp_buf, len);
```



基于传统的 I/O 读取方式，read 系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝，发起数据读取的流程如下：

1. 用户进程通过`read()`函数向内核 (kernel) 发起系统调用，上下文从用户态 (user space) 切换为内核态 (kernel space)；
2. CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到内核空间 (kernel space) 的读缓冲区 (read buffer)；
3. CPU 将读缓冲区 (read buffer) 中的数据拷贝到用户空间 (user space) 的用户缓冲区 (user buffer)。
4. 上下文从内核态 (kernel space) 切换回用户态 (user space)，read 调用执行返回。

##### 传统写操作

当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区(socket buffer)中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。

```java
write(socket_fd, tmp_buf, len);
```

基于传统的 I/O 写入方式，`write()` 系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝，用户程序发送网络数据的流程如下：

1. 用户进程通过 `write()` 函数向内核 (kernel) 发起系统调用，上下文从用户态 (user space) 切换为内核态(kernel space)。
2. CPU 将用户缓冲区 (user buffer) 中的数据拷贝到内核空间 (kernel space) 的网络缓冲区 (socket buffer)。
3. CPU 利用 DMA 控制器将数据从网络缓冲区 (socket buffer) 拷贝到网卡进行数据传输。
4. 上下文从内核态 (kernel space) 切换回用户态 (user space)，write 系统调用执行返回